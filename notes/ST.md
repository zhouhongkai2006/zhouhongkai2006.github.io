# 浅析ST表

> 最近不知为何一直在写倍增……

ST表是专门处理RMQ（静态查询区间最大值）问题的一种数据结构。

它的速度非常快。可以做到$O(nlogn)$的时间建表，$O(1)$的时间查询。

相对于线段树之类的，它查询的速度不知快了几倍。

不过，它也有个缺陷：只能解决RMQ问题。

## 倍增

先来讲讲倍增。

看到倍增两个字，你想到了什么？$2^k$！（自然$k\in \mathbb{N}$）

好。你猜对了。倍增就是跟$2$的次幂有关的。

打个比方：

有个人，开着一架飞机，在一些线性的飞机场从左往右飞。比如：

$$air_1\quad air_2\quad air_3\quad air_4\quad air_5\quad air_6\quad air_7\quad air_8\quad air_9$$

然而，这个人脱离社会，什么现代化的东西都不会用~~那他怎么会开飞机~~。

他根本不知道他起飞和降落的飞机场之间距离是多少。

于是，他拿着纸笔，去打表了……

首先，他从$air_1$起飞，到了$air_2$，他记录下这个$air_1$到$air_2$的距离为$1$……

以此类推，他最终得出了每个机场分别到其他机场需要多少距离。

那么，他一共记下了$9\times 9=81$个数据。飞机场少还好，如果多了，不仅他自己忙不过来，而且表也打不完……

所以就产生了一个办法：我们只记录从某个机场出发飞$2^k$距离的终点机场。

当然，这数据一下子小多了。用表的时候，只要先找到终点机场附近的一个机场（在起点机场的表上），继续沿着这个机场找下去，直到找到为止。

不过，这里就只是说明一下倍增的思想而已，也只是说明一下倍增的方便。

RMQ问题的倍增查询则是$O(1)$的，与这里介绍的不同。

## ST表

懂了倍增，ST表也是挺简单的了。

这里以静态求区间最大值为例。

首先，我们建个表：从每个位置开始跑一遍，每遍用的时间复杂度是$O(logn)$，总的复杂度就是$O(nlogn)$。

自然，求的是这一块长度为$2^k$的区间的最大值。

不过，为了快一点，最好要把$\lfloor log_2(n)\rfloor$全部预处理出来。

下面给出建表的代码：

```pascal
procedure build(n:longint);
begin
  log_2[1]:=0;
  for i:=2 to n do             //预处理log2(n)
    log_2[i]:=log_2[i div 2]+1;
  for i:=1 to n do             //一个数的最大值就是它本身
    f[i,0]:=a[i];
  for j:=1 to log_2[n] do      //枚举区间长度2^j
    for i:=1 to n+1-1 shl i do //枚举区间开始位置
      f[i,j]:=max(f[i,j-1],f[i+1 shl (j-1),j-1]);
end;
```

```c++
void build(int n);
{
    log_2[1]=0;
    for (int i=2;i<=n;i++)     //预处理log2(n)
    {
        log_2[i]=log_2[i/2]+1;
    }
    for (int i=1;1<=n;i++)     //一个数的最大值就是它本身
    {
        f[i,0]=a[i];
    }
    for (int j=1;j<=log_2[n];j++)//枚举区间长度2^j
    {
        for (int i=1;i<=n+1-(1<<j);i++)//枚举区间开始位置
        {
            f[i,j]=max(f[i,j-1],f[i+(1<<j-1),j-1]);
        }
    }
}
```

我们有了这些信息有什么用呢？怎么实现$O(1)$查询呢？

举个例子：计算从$a_2$到$a_{10}$的最大值。一共有$9$个数。

我们知道，$\lfloor log_2(9)\rfloor=3$。所以，我们只要查询从$a_2$开始的$2^3$个数的最大值和$a_{10}$往前的$2^3$个数的最大值再取最大值就行了。

~~似乎有点绕~~

我们知道，只用从开始的一个区间，是不可能完全覆盖整个区间的。所以，要再倒着求一次，才能保证得出正确的答案。

超级简洁的代码：

```pascal
function query(l,r:longint):longint;
 begin
 exit(max(f[l,log2[(r-l+1)]],f[r-1 shl log2[(r-l+1)]+1,log2[(r-l+1)]]);
 end;
```

```c++
int query(int l,int r);
{
    return max(f[l,log_2[r-l+1]],f[r-(1<<log_2[r-l+1])+1,log_2[r-l+1]]);
}
```

总结一下，其实ST表的代码挺简洁的，也很好学。只要了解的倍增的思想就行了。